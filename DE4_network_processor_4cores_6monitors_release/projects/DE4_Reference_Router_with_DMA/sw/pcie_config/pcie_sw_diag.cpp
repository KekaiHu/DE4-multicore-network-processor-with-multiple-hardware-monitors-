/************************************************************************
*  File: pcie_sw_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE_SW
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.31.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/
// =======================================================================================
// Project     : NetFPGA DE4
// 
// Description : DE4 Reference router PCIE software 
//
// Revision Control Information
//
// Author      : RCG
// Revision    : 
// Date        : 
// ======================================================================================	

#include <stdio.h>
#include <string.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "pcie_sw_lib.h"
#include "router_tables.h"
#include "pcie_ethernet_config.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define PCIE_SW_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCIE_SW configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCIE_SW_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define PCIE_SW_CFG_REGS_NUM sizeof(gPCIE_SW_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gPCIE_SW_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCIE_SW_CfgRegs. */
const WDC_REG *gpPCIE_SW_CfgRegs = gPCIE_SW_CfgRegs;

/* -----------------------------------------------
    PCIE_SW run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCIE_SW_Regs[]; */
const WDC_REG *gpPCIE_SW_Regs = NULL;
/* TODO: You can remove the comment from the gPCIE_SW_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpPCIE_SW_Regs to point to gPCIE_SW_Regs. */
#define PCIE_SW_REGS_NUM 0
	
/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_SW_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);

unsigned int OnRCSlaveRead(WDC_DEVICE_HANDLE hDev, int bar, unsigned int addr);
void OnRCSlaveWrite(WDC_DEVICE_HANDLE hDev, int bar, unsigned int addr, unsigned int u32Data);
//void DMA_Read(WDC_DEVICE_HANDLE hDev, unsigned int target_addr, int length);
void DMA_Read(WDC_DEVICE_HANDLE hDev, int port);
void DMA_Write(WDC_DEVICE_HANDLE hDev, int length, int port);
void set_router_tables(WDC_DEVICE_HANDLE hDev);
void config_gige(WDC_DEVICE_HANDLE hDev);
void get_ip_addr(char *ip_address);
void get_mac_addr(char *mac_address);
void get_port(char *port_number);
int load_pcap(char *argument);
unsigned int MAC_HI_ADDR;
unsigned int MAC_LO_ADDR;
unsigned int IP_ADDR;
unsigned int PORT_NUM;
/*************************************************************
  Functions implementation
 *************************************************************/
int main(int c, char *argv[])
{
    WDC_DEVICE_HANDLE hDev = NULL;
    DWORD dwStatus;

    printf("\n");
    printf("PCIE_SW diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE_SW library */
    dwStatus = PCIE_SW_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_SW_ERR("pcie_sw_diag: Failed to initialize the PCIE_SW library: %s",
            PCIE_SW_GetLastErr());
        return dwStatus;
    }
	
    /* Find and open a PCIE_SW device (by default ID) */
    if (PCIE_SW_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_SW_DEFAULT_VENDOR_ID, PCIE_SW_DEFAULT_DEVICE_ID);

    /* Display main diagnostics menu for communicating with the device */
    //MenuMain(&hDev);
	UINT32 ttt = 0;
	WDC_PciReadCfg32(hDev, 0x8, &ttt);
	int Revision_ID = ttt & 0x0f;
	if(Revision_ID != 1){
		printf("This is not SOPC/Qsys design\n");
		return 0;
	}
	
	/* This for configuring the gigabit ehternet interfaces
	*/
	config_gige(hDev);
	/* This for configuring the routing table
	*/
	set_router_tables(hDev);

	/* 
	This for DMA read operation
	load_pcap() function reads the test.pcap file and stores the values in a buffer.
	This packet data is then transferred to reference router CPU queues during 
	DMA_read operation. The DMA_read() function allocates a buffer in the CPU
	memory space and stores the PCAP packet data. When DMA read is initiated by the 
	reference router CPCI module, this data is send through the PCI Express interface
	*/
	//load_pcap(argv[1]);
	//DMA_Read( hDev, 0x3);
	/*
	DMA_Read( hDev, 0x3);
	DMA_Read( hDev, 0x3);
	DMA_Read( hDev, 0x3);
	*/
	/* This for DMA write operation
	Call the function DMA_Write(), if you have packet data stored in CPU queues. This 
	function will transfer one complete packet each time, if data is present in the 
	corresponding CPU queue.
	*/
	//DMA_Write(hDev, 106, 0x3);
	/*
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	DMA_Write(hDev, 106, 0x3);
	*/
    if (hDev)
        DeviceClose(hDev);
 
    dwStatus = PCIE_SW_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_SW_ERR("pcie_sw_diag: Failed to uninit the PCIE_SW library: %s", PCIE_SW_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("PCIE_SW main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCIE_SW device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCIE_SW_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCIE_SW device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCIE_SW configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCIE_SW_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCIE_SW device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a PCIE_SW device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_SW_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        PCIE_SW_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }
    
    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");
    
    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a PCIE_SW device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;
    
    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_SW_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = PCIE_SW_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        PCIE_SW_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            PCIE_SW_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a PCIE_SW device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!PCIE_SW_DeviceClose(hDev))
    {
        PCIE_SW_ERR("DeviceClose: Failed closing PCIE_SW device: %s",
            PCIE_SW_GetLastErr());
    }
}

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = PCIE_SW_GetNumAddrSpaces(hDev);
        
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }
        
        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            PCIE_SW_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and IO ranges\n");
        printf("---------------------------------------------\n");
        printf("%d. Change active address space for read/write "
            "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            (fBlock ? "block transfers" : "non-block transfers"));
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
        {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = PCIE_SW_GetNumAddrSpaces(hDev);
    PCIE_SW_ADDR_SPACE_INFO addrSpaceInfo;
    
    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!PCIE_SW_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            PCIE_SW_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
                PCIE_SW_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
         return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }
            
    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
  
    do {
        /* Display pre-defined registers' information */
        if (PCIE_SW_CFG_REGS_NUM)
        {
            printf("\n");
            printf("Configuration registers:\n");
            printf("------------------------\n");
            WDC_DIAG_RegsInfoPrint(gpPCIE_SW_CfgRegs, PCIE_SW_CFG_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
        }

        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        if (PCIE_SW_CFG_REGS_NUM)
        {
            printf("%d. Read all configuration registers defined for the device (see list above)\n",
                MENU_RW_CFG_SPACE_READ_ALL_REGS);
            printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
            printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        }
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            PCIE_SW_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
            MENU_RW_CFG_SPACE_WRITE_OFFSET))
        {
            continue;
        }
        
        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_SW_CfgRegs, PCIE_SW_CFG_REGS_NUM, TRUE);
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_SW_CfgRegs, PCIE_SW_CFG_REGS_NUM, WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_SW_CfgRegs, PCIE_SW_CFG_REGS_NUM, WDC_WRITE, TRUE);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    
    if (!PCIE_SW_REGS_NUM)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }
  
    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("PCIE_SW run-time registers:\n");
        printf("--------------------------\n");   
        WDC_DIAG_RegsInfoPrint(gpPCIE_SW_Regs, PCIE_SW_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

        printf("\n");
        printf("Read/write the PCIE_SW run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpPCIE_SW_Regs, PCIE_SW_REGS_NUM, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_SW_Regs, PCIE_SW_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpPCIE_SW_Regs, PCIE_SW_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        /* TODO: You can remove this message after you have modified the
           implementation of PCIE_SW_IntEnable() in pcie_sw_lib.c to 
           correctly acknowledge level-sensitive interrupts (see guidelines
           in PCIE_SW_IntEnable()) */
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
           "code of PCIE_SW_IntEnable(), in the file pcie_sw_lib.c, to "
           "correctly acknowledge\n%s interrupts when they occur (as dictated by "
           "the hardware's specifications)\n",
           fIsMsi ? "it's recommended that you" : "you must",
           fIsMsi ? "level sensitive" : "");    }

    do
    {
        fIntEnable = !PCIE_SW_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_ADDR_WRITE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = PCIE_SW_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                    printf("Interrupts enabled\n");
                else
                {
                    PCIE_SW_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
                       dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_SW_IntDisable(hDev))
                    printf("Interrupts disabled\n");
                else
                    PCIE_SW_ERR("Failed disabling interrupts: %s", PCIE_SW_GetLastErr());
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_SW_INT_RESULT *pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !PCIE_SW_EventIsRegistered(hDev);
        
        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");
        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == PCIE_SW_EventRegister(hDev, DiagEventHandler))
                    printf("Events registered\n");
                else
                    PCIE_SW_ERR("Failed to register events. Last error:\n%s", PCIE_SW_GetLastErr());
            }
            else
            {
                if (WD_STATUS_SUCCESS == PCIE_SW_EventUnregister(hDev))
                    printf("Events unregistered\n");
                else
                    PCIE_SW_ERR("Failed to unregister events. Last Error:\n%s", PCIE_SW_GetLastErr());
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics events handler routine */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}

void config_gige(WDC_DEVICE_HANDLE hDev)
{
	/* This function configures the Gigabit ethernet interface
	*/

	/******************Ethernet 1 config **********************/
	
	/***********************MAC1 config***********************/
	unsigned int ret;
    printf("Start MAC1 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00001000, 0x00000000);

	OnRCSlaveWrite(hDev, 1, MAC_SCRATCH_ADDRESS, MAC_SCRATCH);
	ret = OnRCSlaveRead(hDev, 1, MAC_SCRATCH_ADDRESS);
	printf("%x : %x\n", MAC_SCRATCH_ADDRESS, ret);

	OnRCSlaveWrite(hDev, 1, COMMAND_CONFIG_ADDRESS, COMMAND_CONFIG_VALUE);
	ret = OnRCSlaveRead(hDev, 1, COMMAND_CONFIG_ADDRESS);
	printf("%x : %x\n", COMMAND_CONFIG_ADDRESS, ret);

	OnRCSlaveWrite(hDev, 1, MAC_0_ADDRESS, MAC_0);
	ret = OnRCSlaveRead(hDev, 1, MAC_0_ADDRESS);
	printf("%x : %x\n", MAC_0_ADDRESS, ret);

	OnRCSlaveWrite(hDev, 1, MAC_1_ADDRESS, MAC_1);	
	 ret = OnRCSlaveRead(hDev, 1, MAC_1_ADDRESS);
	printf("%x : %x\n", MAC_1_ADDRESS, ret);

	OnRCSlaveWrite(hDev, 1, FRM_LENGTH_ADDRESS, FRM_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, FRM_LENGTH_ADDRESS);
	printf("%x : %x\n", FRM_LENGTH_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, PAUSE_QUANT_ADDRESS, PAUSE_QUANT);
	ret = OnRCSlaveRead(hDev, 1, PAUSE_QUANT_ADDRESS);
	printf("%x : %x\n", PAUSE_QUANT_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_EMPTY_ADDRESS, RX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_EMPTY_ADDRESS);
	printf("%x : %x\n", RX_SECTION_EMPTY_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_FULL_ADDRESS, RX_SECTION_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_FULL_ADDRESS);
	printf("%x : %x\n", RX_SECTION_FULL_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_EMPTY_ADDRESS, TX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_EMPTY_ADDRESS);
	printf("%x : %x\n", TX_SECTION_EMPTY_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_FULL_ADDRESS, TX_SECTION_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_FULL_ADDRESS);
	printf("%x : %x\n", TX_SECTION_FULL_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_EMPTY_ADDRESS, RX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_EMPTY_ADDRESS);
	printf("%x : %x\n", RX_ALMOST_EMPTY_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_FULL_ADDRESS, RX_ALMOST_FULL);
    ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_FULL_ADDRESS);
	printf("%x : %x\n", RX_ALMOST_FULL_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_EMPTY_ADDRESS, TX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_EMPTY_ADDRESS);
	printf("%x : %x\n", TX_ALMOST_EMPTY_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_FULL_ADDRESS, TX_ALMOST_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_FULL_ADDRESS);
	printf("%x : %x\n", TX_ALMOST_FULL_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR0_ADDRESS, MDIO_ADDR0);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR0_ADDRESS);
	printf("%x : %x\n", MDIO_ADDR0_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR1_ADDRESS, MDIO_ADDR1);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR1_ADDRESS);
	printf("%x : %x\n", MDIO_ADDR1_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_IPG_LENGTH_ADDRESS, TX_IPG_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, TX_IPG_LENGTH_ADDRESS);
	printf("%x : %x\n", TX_IPG_LENGTH_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_CMD_STAT_ADDRESS, TX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, TX_CMD_STAT_ADDRESS);
	printf("%x : %x\n", TX_CMD_STAT_ADDRESS, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_CMD_STAT_ADDRESS, RX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, RX_CMD_STAT_ADDRESS);
	printf("%x : %x\n", RX_CMD_STAT_ADDRESS, ret);
	
	printf("MAC1 configure ends \n");

	/***********************PCS1 config***********************/
	
	printf("Start PCS1 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00000900, PCS_SCRATCH); // PCS_SCRATCH_ADDR1
	OnRCSlaveWrite(hDev, 1, 0x00000940, PCS_IF_MODE); // PCS_IF_MODE_ADDR1
	OnRCSlaveWrite(hDev, 1, 0x00000800, PCS_CONTROL_REG); // PCS_CONTROL_REG_ADDR1
	printf("PCS1 configure ends \n");
	
    printf("Waiting Link Up..... \n");
	

	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000810);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0004;
	if (tse_pcs_register_value_temp == 0x00000004 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Link is established! \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Link lost with time-out! \n");
	   }
	}
	
	//PCS Partner_Ability for SGMII
	printf("Partner Ability: \n");
	PCS_COUNT_TEMP = 0;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	 tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000850);
	 tse_pcs_register_value_temp = (tse_pcs_register_value_temp & 0x8000);
	 if (tse_pcs_register_value_temp == 0x00008000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Copper link interface is up. \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Copper link interface is down. \n");
	   }
	}
    
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x1000;
	
	if (tse_pcs_register_value_temp == 0x00001000)
		{printf("Copper operating in Full Duplex mode. \n");}
	else {printf("Copper operating in Half Duplex mode. \n");}

	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0c00;
	
	if (tse_pcs_register_value_temp == 0x00000000)
		{printf("Copper operating Speed 10Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000400) 
		{printf("Copper operating Speed 100Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000800) 
		{printf("Copper operating Speed 1000Mbps \n");}
	else
		{printf("Copper operating Speed Error! \n");}
		printf("PCS1 configure Ends\n");
	
	/***********************PHY1 config***********************/
	
	printf("Start PHY1 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00001000, PHY_ADDR);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00000a40, PHY_AN_AD);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00000a90, PHY_READ_1000BASE);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00000b00, PHY_SPEC_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00000bb0, PHY_EXTENDED_STATUS);
	OnRCSlaveWrite(hDev, 1, 0x00000a00, SOFT_REST);
	

	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0400;
	if (quad_phy_register_value_temp == 0x00000400 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY is linked! \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY lost with time-out! \n");
	   }
	}
	
	PHY_COUNT_TEMP = 0;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0800;
	if (quad_phy_register_value_temp == 0x00000800 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolved. \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolve Failed! \n");
	   }
	}
	
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x2000;
	
	if (quad_phy_register_value_temp == 0x00002000) {
		printf("PHY operating in Full Duplex mode. \n");
	} else {
		printf("PHY operating in Half Duplex mode. \n");
	}

    quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00000b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0xC000;
	if (quad_phy_register_value_temp == 0x00000000)
		{printf("PHY operating Speed 10Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00004000) 
		{printf("PHY operating Speed 100Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00008000) 
		{printf("PHY operating Speed 1000Mbps \n");}
	else
		{printf("PHY operating Speed Error! \n");}
		printf("PHY1 configure ends\n");
	
	
	/**********************************************************/
	/******************Ethernet 2 config **********************/
	
	/***********************MAC2 config***********************/
	
	printf("Start MAC2 configure \n");
	
	OnRCSlaveWrite(hDev, 1, 0x00002000, 0x00000000);
	ret = OnRCSlaveRead(hDev, 1, 0x00002000);
	printf("%x : %x\n", 0x00008000, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_SCRATCH_ADDRESS_2, MAC_SCRATCH);
	ret = OnRCSlaveRead(hDev, 1, MAC_SCRATCH_ADDRESS_2);
	printf("%x : %x\n", MAC_SCRATCH_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, COMMAND_CONFIG_ADDRESS_2, COMMAND_CONFIG_VALUE);
	ret = OnRCSlaveRead(hDev, 1, COMMAND_CONFIG_ADDRESS_2);
	printf("%x : %x\n", COMMAND_CONFIG_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_0_ADDRESS_2, MAC_0_2);
	ret = OnRCSlaveRead(hDev, 1, MAC_0_ADDRESS_2);
	printf("%x : %x\n", MAC_0_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_1_ADDRESS_2, MAC_1_2);	
	ret = OnRCSlaveRead(hDev, 1, MAC_1_ADDRESS_2);
	printf("%x : %x\n", MAC_1_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, FRM_LENGTH_ADDRESS_2, FRM_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, FRM_LENGTH_ADDRESS_2);
	printf("%x : %x\n", FRM_LENGTH_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, PAUSE_QUANT_ADDRESS_2, PAUSE_QUANT);
	ret = OnRCSlaveRead(hDev, 1, PAUSE_QUANT_ADDRESS_2);
	printf("%x : %x\n", PAUSE_QUANT_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_EMPTY_ADDRESS_2, RX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_EMPTY_ADDRESS_2);
	printf("%x : %x\n", RX_SECTION_EMPTY_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_FULL_ADDRESS_2, RX_SECTION_FULL);
    ret = OnRCSlaveRead(hDev, 1, RX_SECTION_FULL_ADDRESS_2);
	printf("%x : %x\n", RX_SECTION_FULL_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_EMPTY_ADDRESS_2, TX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_EMPTY_ADDRESS_2);
	printf("%x : %x\n", TX_SECTION_EMPTY_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_FULL_ADDRESS_2, TX_SECTION_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_FULL_ADDRESS_2);
	printf("%x : %x\n", TX_SECTION_FULL_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_2, RX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_2);
	printf("%x : %x\n", RX_ALMOST_EMPTY_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_FULL_ADDRESS_2, RX_ALMOST_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_FULL_ADDRESS_2);
	printf("%x : %x\n", RX_ALMOST_FULL_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_2, TX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_2);
	printf("%x : %x\n", TX_ALMOST_EMPTY_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_FULL_ADDRESS_2, TX_ALMOST_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_FULL_ADDRESS_2);
	printf("%x : %x\n", TX_ALMOST_FULL_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR0_ADDRESS_2, MDIO_ADDR0);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR0_ADDRESS_2);
	printf("%x : %x\n", MDIO_ADDR0_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR1_ADDRESS_2, MDIO_ADDR1);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR1_ADDRESS_2);
	printf("%x : %x\n", MDIO_ADDR1_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_IPG_LENGTH_ADDRESS_2, TX_IPG_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, TX_IPG_LENGTH_ADDRESS_2);
	printf("%x : %x\n", TX_IPG_LENGTH_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_CMD_STAT_ADDRESS_2, TX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, TX_CMD_STAT_ADDRESS_2);
	printf("%x : %x\n", TX_CMD_STAT_ADDRESS_2, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_CMD_STAT_ADDRESS_2, RX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, RX_CMD_STAT_ADDRESS_2);
	printf("%x : %x\n", RX_CMD_STAT_ADDRESS_2, ret);
	
	printf("MAC2 configure ends \n");
	
	/***********************PCS2 config***********************/	
	//PCS2 config
	printf("Start PCS2 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00001900, PCS_SCRATCH);
	OnRCSlaveWrite(hDev, 1, 0x00001940, PCS_IF_MODE);
	OnRCSlaveWrite(hDev, 1, 0x00001800, PCS_CONTROL_REG);
	
	printf("Waiting Link Up..... \n");
	PCS_COUNT_TEMP = 0;
    PCS_TIMEOUT = 1000;
    tse_pcs_register_value_temp = 0;
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001810);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0004;
	if (tse_pcs_register_value_temp == 0x00000004 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Link is established! \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Link lost with time-out! \n");
	   }
	}
	
	//PCS Partner_Ability for SGMII
	printf("Partner Ability: \n");
	PCS_COUNT_TEMP = 0;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	 tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001850);
	 tse_pcs_register_value_temp = (tse_pcs_register_value_temp & 0x8000);
	 if (tse_pcs_register_value_temp == 0x00008000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Copper link interface is up. \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Copper link interface is down. \n");
	   }
	}
    
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x1000;
	
	if (tse_pcs_register_value_temp == 0x00001000)
	{printf("Copper operating in Full Duplex mode. \n");}
	else {printf("Copper operating in Half Duplex mode. \n");}

	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0c00;
	
	if (tse_pcs_register_value_temp == 0x00000000)
		{printf("Copper operating Speed 10Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000400) 
		{printf("Copper operating Speed 100Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000800) 
		{printf("Copper operating Speed 1000Mbps \n");}
	else
		{printf("Copper operating Speed Error! \n");}
		printf("PCS2 configure ends \n");

	/***********************PHY2 config***********************/
	printf("Start PHY2 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00001100, PHY_ADDR_2);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00001a40, PHY_AN_AD);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00001a90, PHY_READ_1000BASE);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00001b00, PHY_SPEC_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00001bb0, PHY_EXTENDED_STATUS);
	OnRCSlaveWrite(hDev, 1, 0x00001a00, SOFT_REST);
	PHY_COUNT_TEMP = 0;
    PHY_TIMEOUT = 1000;
    quad_phy_register_value_temp = 0;

	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0400;
	if (quad_phy_register_value_temp == 0x00000400 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY is linked! \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY lost with time-out! \n");
	   }
	}
	
	PHY_COUNT_TEMP = 0;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0800;
	if (quad_phy_register_value_temp == 0x00000800 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolved. \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolve Failed! \n");
	   }
	}
	
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x2000;
	
	if (quad_phy_register_value_temp == 0x00002000) {
		printf("PHY operating in Full Duplex mode. \n");
	} else {
		printf("PHY operating in Half Duplex mode. \n");
	}

    quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00001b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0xC000;
	if (quad_phy_register_value_temp == 0x00000000)
		{printf("PHY operating Speed 10Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00004000) 
		{printf("PHY operating Speed 100Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00008000) 
		{printf("PHY operating Speed 1000Mbps \n");}
	else
		{printf("PHY operating Speed Error! \n");}
		printf("PHY2 configure ends \n");
	
	/**********************************************************/
	/******************Ethernet 3 config **********************/
	
	/***********************MAC3 config***********************/	
	
	OnRCSlaveWrite(hDev, 1, 0x00003000, 0x00000000);
	ret = OnRCSlaveRead(hDev, 1, 0x00003000);
	printf("%x : %x\n", 0x0000C000, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_SCRATCH_ADDRESS_3, MAC_SCRATCH);
	ret = OnRCSlaveRead(hDev, 1, MAC_SCRATCH_ADDRESS_3);
	printf("%x : %x\n", MAC_SCRATCH_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, COMMAND_CONFIG_ADDRESS_3, COMMAND_CONFIG_VALUE);
	ret = OnRCSlaveRead(hDev, 1, COMMAND_CONFIG_ADDRESS_3);
	printf("%x : %x\n", COMMAND_CONFIG_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_0_ADDRESS_3, MAC_0_3);
	ret = OnRCSlaveRead(hDev, 1, MAC_0_ADDRESS_3);
	printf("%x : %x\n", MAC_0_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_1_ADDRESS_3, MAC_1_3);	
	ret = OnRCSlaveRead(hDev, 1, MAC_1_ADDRESS_3);
	printf("%x : %x\n", MAC_1_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, FRM_LENGTH_ADDRESS_3, FRM_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, FRM_LENGTH_ADDRESS_3);
	printf("%x : %x\n", FRM_LENGTH_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, PAUSE_QUANT_ADDRESS_3, PAUSE_QUANT);
	ret = OnRCSlaveRead(hDev, 1, PAUSE_QUANT_ADDRESS_3);
	printf("%x : %x\n", PAUSE_QUANT_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_EMPTY_ADDRESS_3, RX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_EMPTY_ADDRESS_3);
	printf("%x : %x\n", RX_SECTION_EMPTY_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_FULL_ADDRESS_3, RX_SECTION_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_FULL_ADDRESS_3);
	printf("%x : %x\n", RX_SECTION_FULL_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_EMPTY_ADDRESS_3, TX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_EMPTY_ADDRESS_3);
	printf("%x : %x\n", TX_SECTION_EMPTY_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_FULL_ADDRESS_3, TX_SECTION_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_FULL_ADDRESS_3);
	printf("%x : %x\n", TX_SECTION_FULL_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_3, RX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_3);
	printf("%x : %x\n", RX_ALMOST_EMPTY_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_FULL_ADDRESS_3, RX_ALMOST_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_FULL_ADDRESS_3);
	printf("%x : %x\n", RX_ALMOST_FULL_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_3, TX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_3);
	printf("%x : %x\n", TX_ALMOST_EMPTY_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_FULL_ADDRESS_3, TX_ALMOST_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_FULL_ADDRESS_3);
	printf("%x : %x\n", TX_ALMOST_FULL_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR0_ADDRESS_3, MDIO_ADDR0);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR0_ADDRESS_3);
	printf("%x : %x\n", MDIO_ADDR0_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR1_ADDRESS_3, MDIO_ADDR1);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR1_ADDRESS_3);
	printf("%x : %x\n", MDIO_ADDR1_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_IPG_LENGTH_ADDRESS_3, TX_IPG_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, TX_IPG_LENGTH_ADDRESS_3);
	printf("%x : %x\n", TX_IPG_LENGTH_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_CMD_STAT_ADDRESS_3, TX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, TX_CMD_STAT_ADDRESS_3);
	printf("%x : %x\n", TX_CMD_STAT_ADDRESS_3, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_CMD_STAT_ADDRESS_3, RX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, RX_CMD_STAT_ADDRESS_3);
	printf("%x : %x\n", RX_CMD_STAT_ADDRESS_3, ret);
	
	printf("MAC3 configure ends \n");
	
	/***********************PCS3 config***********************/
    printf("Start PCS3 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00002900, PCS_SCRATCH);
	OnRCSlaveWrite(hDev, 1, 0x00002940, PCS_IF_MODE);
	OnRCSlaveWrite(hDev, 1, 0x00002800, PCS_CONTROL_REG);
	printf("PCS3 configure ends \n");
	printf("Waiting Link Up..... \n");
	
	PCS_COUNT_TEMP = 0;
    PCS_TIMEOUT = 1000;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002810);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0004;
	if (tse_pcs_register_value_temp == 0x00000004 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Link is established! \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Link lost with time-out! \n");
	   }
	}
	
	//PCS Partner_Ability for SGMII
	printf("Partner Ability: \n");
	PCS_COUNT_TEMP = 0;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	 tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002850);
	 tse_pcs_register_value_temp = (tse_pcs_register_value_temp & 0x8000);
	 if (tse_pcs_register_value_temp == 0x00008000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Copper link interface is up. \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Copper link interface is down. \n");
	   }
	}
    
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x1000;
	
	if (tse_pcs_register_value_temp == 0x00001000)
	{printf("Copper operating in Full Duplex mode. \n");}
	else {printf("Copper operating in Half Duplex mode. \n");}

	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0c00;
	
	if (tse_pcs_register_value_temp == 0x00000000)
		{printf("Copper operating Speed 10Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000400) 
		{printf("Copper operating Speed 100Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000800) 
		{printf("Copper operating Speed 1000Mbps \n");}
	else
		{printf("Copper operating Speed Error! \n");}
	
	/***********************PHY3 config***********************/
	printf("Start PHY3 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00002100, PHY_ADDR_3);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00002a40, PHY_AN_AD);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00002a90, PHY_READ_1000BASE);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00002b00, PHY_SPEC_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00002bb0, PHY_EXTENDED_STATUS);
	OnRCSlaveWrite(hDev, 1, 0x00002a00, SOFT_REST);
	printf("PHY3 configure ends \n");
	
	PHY_COUNT_TEMP = 0;
    PHY_TIMEOUT = 1000;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0400;
	if (quad_phy_register_value_temp == 0x00000400 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY is linked! \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY lost with time-out! \n");
	   }
	}
	
	PHY_COUNT_TEMP = 0;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0800;
	if (quad_phy_register_value_temp == 0x00000800 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolved. \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolve Failed! \n");
	   }
	}
	
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x2000;
	
	if (quad_phy_register_value_temp == 0x00002000) {
		printf("PHY operating in Full Duplex mode. \n");
	} else {
		printf("PHY operating in Half Duplex mode. \n");
	}

    quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00002b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0xC000;
	
	if (quad_phy_register_value_temp == 0x00000000)
		{printf("PHY operating Speed 10Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00004000) 
		{printf("PHY operating Speed 100Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00008000) 
		{printf("PHY operating Speed 1000Mbps \n");}
	else
		{printf("PHY operating Speed Error! \n");}
	

	/**********************************************************/
	/******************Ethernet 4 config **********************/
	
	/***********************MAC4 config***********************/
	OnRCSlaveWrite(hDev, 1, 0x00004000, 0x00000000);
	ret = OnRCSlaveRead(hDev, 1, 0x00004000);
	printf("%x : %x\n", 0x00004000, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_SCRATCH_ADDRESS_4, MAC_SCRATCH);
	ret = OnRCSlaveRead(hDev, 1, MAC_SCRATCH_ADDRESS_4);
	printf("%x : %x\n", MAC_SCRATCH_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, COMMAND_CONFIG_ADDRESS_4, COMMAND_CONFIG_VALUE);
	ret = OnRCSlaveRead(hDev, 1, COMMAND_CONFIG_ADDRESS_4);
	printf("%x : %x\n", COMMAND_CONFIG_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_0_ADDRESS_4, MAC_0_4);
	ret = OnRCSlaveRead(hDev, 1, MAC_0_ADDRESS_4);
	printf("%x : %x\n", MAC_0_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, MAC_1_ADDRESS_4, MAC_1_4);	
	ret = OnRCSlaveRead(hDev, 1, MAC_1_ADDRESS_4);
	printf("%x : %x\n", MAC_1_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, FRM_LENGTH_ADDRESS_4, FRM_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, FRM_LENGTH_ADDRESS_4);
	printf("%x : %x\n", FRM_LENGTH_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, PAUSE_QUANT_ADDRESS_4, PAUSE_QUANT);
	ret = OnRCSlaveRead(hDev, 1, PAUSE_QUANT_ADDRESS_4);
	printf("%x : %x\n", PAUSE_QUANT_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_EMPTY_ADDRESS_4, RX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_EMPTY_ADDRESS_4);
	printf("%x : %x\n", RX_SECTION_EMPTY_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_SECTION_FULL_ADDRESS_4, RX_SECTION_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_SECTION_FULL_ADDRESS_4);
	printf("%x : %x\n", RX_SECTION_FULL_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_EMPTY_ADDRESS_4, TX_SECTION_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_EMPTY_ADDRESS_4);
	printf("%x : %x\n", TX_SECTION_EMPTY_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_SECTION_FULL_ADDRESS_4, TX_SECTION_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_SECTION_FULL_ADDRESS_4);
	printf("%x : %x\n", TX_SECTION_FULL_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_4, RX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_EMPTY_ADDRESS_4);
	printf("%x : %x\n", RX_ALMOST_EMPTY_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_ALMOST_FULL_ADDRESS_4, RX_ALMOST_FULL);	
	ret = OnRCSlaveRead(hDev, 1, RX_ALMOST_FULL_ADDRESS_4);
	printf("%x : %x\n", RX_ALMOST_FULL_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_4, TX_ALMOST_EMPTY);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_EMPTY_ADDRESS_4);
	printf("%x : %x\n", TX_ALMOST_EMPTY_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_ALMOST_FULL_ADDRESS_4, TX_ALMOST_FULL);
	ret = OnRCSlaveRead(hDev, 1, TX_ALMOST_FULL_ADDRESS_4);
	printf("%x : %x\n", TX_ALMOST_FULL_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR0_ADDRESS_4, MDIO_ADDR0);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR0_ADDRESS_4);
	printf("%x : %x\n", MDIO_ADDR0_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, MDIO_ADDR1_ADDRESS_4, MDIO_ADDR1);
	ret = OnRCSlaveRead(hDev, 1, MDIO_ADDR1_ADDRESS_4);
	printf("%x : %x\n", MDIO_ADDR1_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_IPG_LENGTH_ADDRESS_4, TX_IPG_LENGTH);
	ret = OnRCSlaveRead(hDev, 1, TX_IPG_LENGTH_ADDRESS_4);
	printf("%x : %x\n", TX_IPG_LENGTH_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, TX_CMD_STAT_ADDRESS_4, TX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, TX_CMD_STAT_ADDRESS_4);
	printf("%x : %x\n", TX_CMD_STAT_ADDRESS_4, ret);
	
	OnRCSlaveWrite(hDev, 1, RX_CMD_STAT_ADDRESS_4, RX_CMD_STAT_VALUE);
	ret = OnRCSlaveRead(hDev, 1, RX_CMD_STAT_ADDRESS_4);
	printf("%x : %x\n", RX_CMD_STAT_ADDRESS_4, ret);
	
	printf("MAC4 configure ends\n");
	
	/***********************PCS4 config***********************/
	
    printf("Start PCS4 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00003900, PCS_SCRATCH);
	OnRCSlaveWrite(hDev, 1, 0x00003940, PCS_IF_MODE);
	OnRCSlaveWrite(hDev, 1, 0x00003800, PCS_CONTROL_REG);
	printf("PCS4 configure ends \n");
	
	printf("Waiting Link Up..... \n");
	
	PCS_COUNT_TEMP = 0;
    PCS_TIMEOUT = 1000;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003810);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0004;
	if (tse_pcs_register_value_temp == 0x00000004 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Link is established! \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Link lost with time-out! \n");
	   }
	}
	
	//PCS Partner_Ability for SGMII
	printf("Partner Ability: \n");
	PCS_COUNT_TEMP = 0;
    tse_pcs_register_value_temp = 0;
	
	while ( tse_pcs_register_value_temp == 0x00000000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	{
	 tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003850);
	 tse_pcs_register_value_temp = (tse_pcs_register_value_temp & 0x8000);
	 if (tse_pcs_register_value_temp == 0x00008000 && PCS_COUNT_TEMP < PCS_TIMEOUT)
	   {
	    printf("Copper link interface is up. \n");
	   }
	PCS_COUNT_TEMP = PCS_COUNT_TEMP + 1;
	if (PCS_COUNT_TEMP == PCS_TIMEOUT)
	   {
	    printf("Copper link interface is down. \n");
	   }
	}
    
	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x1000;
	
	if (tse_pcs_register_value_temp == 0x00001000)
	{printf("Copper operating in Full Duplex mode. \n");}
	else {printf("Copper operating in Half Duplex mode. \n");}

	tse_pcs_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003850);
	tse_pcs_register_value_temp = tse_pcs_register_value_temp & 0x0c00;
	
	if (tse_pcs_register_value_temp == 0x00000000)
		{printf("Copper operating Speed 10Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000400) 
		{printf("Copper operating Speed 100Mbps \n");}
	else if (tse_pcs_register_value_temp == 0x00000800) 
		{printf("Copper operating Speed 1000Mbps \n");}
	else
		{printf("Copper operating Speed Error! \n");}
	
	/***********************PHY4 config***********************/
	
	printf("Start PHY4 configure \n");
	OnRCSlaveWrite(hDev, 1, 0x00003100, PHY_ADDR_4);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, PHY_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00003a40, PHY_AN_AD);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00003a90, PHY_READ_1000BASE);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00003b00, PHY_SPEC_CONTROL_REG);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, SOFT_REST);
	OnRCSlaveWrite(hDev, 1, 0x00003bb0, PHY_EXTENDED_STATUS);
	OnRCSlaveWrite(hDev, 1, 0x00003a00, SOFT_REST);
	printf("PHY4 configure ends \n");

	PHY_COUNT_TEMP = 0;
    PHY_TIMEOUT = 1000;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0400;
	if (quad_phy_register_value_temp == 0x00000400 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY is linked! \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY lost with time-out! \n");
	   }
	}
	
	PHY_COUNT_TEMP = 0;
    quad_phy_register_value_temp = 0;
	
	while ( quad_phy_register_value_temp == 0x00000000 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	{
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x0800;
	if (quad_phy_register_value_temp == 0x00000800 && PHY_COUNT_TEMP < PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolved. \n");
	   }
	PHY_COUNT_TEMP = PHY_COUNT_TEMP + 1;
	if (PHY_COUNT_TEMP == PHY_TIMEOUT)
	   {
	    printf("PHY Speed and Duplex Resolve Failed! \n");
	   }
	}
	
	quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0x2000;
	
	if (quad_phy_register_value_temp == 0x00002000) {
		printf("PHY operating in Full Duplex mode. \n");
	} else {
		printf("PHY operating in Half Duplex mode. \n");
	}

    quad_phy_register_value_temp = OnRCSlaveRead(hDev, 1, 0x00003b10);
	quad_phy_register_value_temp = quad_phy_register_value_temp & 0xC000;
	
	if (quad_phy_register_value_temp == 0x00000000)
		{printf("PHY operating Speed 10Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00004000) 
		{printf("PHY operating Speed 100Mbps \n");}
	else if (quad_phy_register_value_temp == 0x00008000) 
		{printf("PHY operating Speed 1000Mbps \n");}
	else
		{printf("PHY operating Speed Error! \n");}
}

void get_mac_addr(char *mac_address)
{
	/* This function parses MAC address values
	*/
	unsigned int mac_addr[6];
	char str[30];
	strcpy(str,mac_address);
	sscanf((strtok(str,":")),"%x",&mac_addr[0]);
	sscanf((strtok(NULL,":")),"%x",&mac_addr[1]);
	sscanf((strtok(NULL,":")),"%x",&mac_addr[2]);
	sscanf((strtok(NULL,":")),"%x",&mac_addr[3]);
	sscanf((strtok(NULL,":")),"%x",&mac_addr[4]);
	sscanf((strtok(NULL,":")),"%x",&mac_addr[5]);
	MAC_HI_ADDR = (mac_addr[0]);
	MAC_HI_ADDR = (MAC_HI_ADDR << 8) + mac_addr[1];
	MAC_LO_ADDR = (mac_addr[2]);
	MAC_LO_ADDR = (MAC_LO_ADDR <<8 ) + mac_addr[3];
	MAC_LO_ADDR = (MAC_LO_ADDR <<8 ) + mac_addr[4];
	MAC_LO_ADDR = (MAC_LO_ADDR <<8 ) + mac_addr[5];
}

void get_ip_addr(char *ip_address)
{
	/* This function parses IP address values
	*/
	unsigned int ip_addr[4];
	char str[30];
	char buf[2];
	strcpy(str,ip_address);
	sscanf((strtok(str,".")),"%d",&ip_addr[0]);
	sscanf((strtok(NULL,".")),"%d",&ip_addr[1]);
	sscanf((strtok(NULL,".")),"%d",&ip_addr[2]);
	sscanf((strtok(NULL,".")),"%d",&ip_addr[3]);
	IP_ADDR = ip_addr[0];
	IP_ADDR = (IP_ADDR << 8) + ip_addr[1];
	IP_ADDR = (IP_ADDR << 8) + ip_addr[2];
	IP_ADDR = (IP_ADDR << 8) + ip_addr[3];

}

void get_port(char *port_number)
{
	/* This function parses Port number.
	*/
	unsigned int port_no;
	char str[5];
	strcpy(str,port_number);
	sscanf((strtok(str,"\0")),"%x",&port_no);
	PORT_NUM = port_no;
}

void set_router_tables(WDC_DEVICE_HANDLE hDev)
{
	/* This function configure the reference router routing table
	*/
	unsigned int ret;
	char *mac_address;
	char *ip_address;
	char *port_number;
	// MAC variables
	unsigned int MAC_0_HI;
	unsigned int MAC_0_LO;
	unsigned int MAC_1_HI;
	unsigned int MAC_1_LO;
	unsigned int MAC_2_HI;
	unsigned int MAC_2_LO;
	unsigned int MAC_3_HI;
	unsigned int MAC_3_LO;

	// DESTIP variables
	unsigned int IP_REG_00;
	unsigned int IP_REG_01;
	unsigned int IP_REG_02;
	unsigned int IP_REG_03;

	// ARP variables
	unsigned int ARP_NEXT_HOP_IP_REG_01; 
	unsigned int ARP_MAC_HI_REG_01; 
	unsigned int ARP_MAC_LO_REG_01; 
	unsigned int ARP_NEXT_HOP_IP_REG_02; 
	unsigned int ARP_MAC_HI_REG_02; 
	unsigned int ARP_MAC_LO_REG_02; 
	unsigned int ARP_NEXT_HOP_IP_REG_03; 
	unsigned int ARP_MAC_HI_REG_03; 
	unsigned int ARP_MAC_LO_REG_03; 
	unsigned int ARP_NEXT_HOP_IP_REG_04; 
	unsigned int ARP_MAC_HI_REG_04; 
	unsigned int ARP_MAC_LO_REG_04; 

	// LPM variables
	unsigned int LPM_IP_REG_01; 
	unsigned int MASK_REG_01;
	unsigned int LPM_NEXT_HOP_IP_REG_01; 
	unsigned int LPM_OUTPUT_PORT_REG_01;
	unsigned int LPM_IP_REG_02; 
	unsigned int MASK_REG_02;
	unsigned int LPM_NEXT_HOP_IP_REG_02; 
	unsigned int LPM_OUTPUT_PORT_REG_02;
	unsigned int LPM_IP_REG_03; 
	unsigned int MASK_REG_03;
	unsigned int LPM_NEXT_HOP_IP_REG_03; 
	unsigned int LPM_OUTPUT_PORT_REG_03;
	unsigned int LPM_IP_REG_04; 
	unsigned long MASK_REG_04;
	unsigned int LPM_NEXT_HOP_IP_REG_04; 
	unsigned int LPM_OUTPUT_PORT_REG_04;

	// MAC 0
	mac_address = MAC_ADDR_0;
	get_mac_addr(mac_address);
	MAC_0_HI = MAC_HI_ADDR;
	MAC_0_LO = MAC_LO_ADDR;

	// MAC 1
	mac_address = MAC_ADDR_1;
	get_mac_addr(mac_address);
	MAC_1_HI = MAC_HI_ADDR;
	MAC_1_LO = MAC_LO_ADDR;

	// MAC 2
	mac_address = MAC_ADDR_2;
	get_mac_addr(mac_address);
	MAC_2_HI = MAC_HI_ADDR;
	MAC_2_LO = MAC_LO_ADDR;

	// MAC 3
	mac_address = MAC_ADDR_3;
	get_mac_addr(mac_address);
	MAC_3_HI = MAC_HI_ADDR;
	MAC_3_LO = MAC_LO_ADDR;

	// Destip 0
	ip_address = DEST_IP_0;
	get_ip_addr(ip_address);
	IP_REG_00 = IP_ADDR;

	// Destip 1
	ip_address = DEST_IP_1;
	get_ip_addr(ip_address);
	IP_REG_01 = IP_ADDR;

	// Destip 2
	ip_address = DEST_IP_2;
	get_ip_addr(ip_address);
	IP_REG_02 = IP_ADDR;

	// Destip 3
	ip_address = DEST_IP_3;
	get_ip_addr(ip_address);
	IP_REG_03 = IP_ADDR;

	// lpm 1
	ip_address = LPM_IP_1;
	get_ip_addr(ip_address);
	LPM_IP_REG_01 = IP_ADDR;

	ip_address = LPM_MASK_1;
	get_ip_addr(ip_address);
	MASK_REG_01 = IP_ADDR;

	ip_address = LPM_NEXT_HOP_IP_1;
	get_ip_addr(ip_address);
	LPM_NEXT_HOP_IP_REG_01 = IP_ADDR;

	port_number = LPM_OUTPUT_PORT_1;
	get_port(port_number);
	LPM_OUTPUT_PORT_REG_01 = PORT_NUM;

	// lpm 2
	ip_address = LPM_IP_2;
	get_ip_addr(ip_address);
	LPM_IP_REG_02 = IP_ADDR;

	ip_address = LPM_MASK_2;
	get_ip_addr(ip_address);
	MASK_REG_02 = IP_ADDR;

	ip_address = LPM_NEXT_HOP_IP_2;
	get_ip_addr(ip_address);
	LPM_NEXT_HOP_IP_REG_02 = IP_ADDR;

	port_number = LPM_OUTPUT_PORT_2;
	get_port(port_number);
	LPM_OUTPUT_PORT_REG_02 = PORT_NUM;

	// Arp 1
	ip_address = NEXT_HOP_IP_1;
	get_ip_addr(ip_address);
	ARP_NEXT_HOP_IP_REG_01 = IP_ADDR;

	mac_address = NEXT_HOP_MAC_1;
	get_mac_addr(mac_address);
	ARP_MAC_HI_REG_01 = MAC_HI_ADDR;
	ARP_MAC_LO_REG_01 = MAC_LO_ADDR;

	// Arp 2
	ip_address = NEXT_HOP_IP_2;
	get_ip_addr(ip_address);
	ARP_NEXT_HOP_IP_REG_02 = IP_ADDR;

	mac_address = NEXT_HOP_MAC_2;
	get_mac_addr(mac_address);
	ARP_MAC_HI_REG_02 = MAC_HI_ADDR;
	ARP_MAC_LO_REG_02 = MAC_LO_ADDR;

	// Arp 3
	ip_address = NEXT_HOP_IP_3;
	get_ip_addr(ip_address);
	ARP_NEXT_HOP_IP_REG_03 = IP_ADDR;

	mac_address = NEXT_HOP_MAC_3;
	get_mac_addr(mac_address);
	ARP_MAC_HI_REG_03 = MAC_HI_ADDR;
	ARP_MAC_LO_REG_03 = MAC_LO_ADDR;

	// Arp 4
	ip_address = NEXT_HOP_IP_4;
	get_ip_addr(ip_address);
	ARP_NEXT_HOP_IP_REG_04 = IP_ADDR;

	mac_address = NEXT_HOP_MAC_4;
	get_mac_addr(mac_address);
	ARP_MAC_HI_REG_04 = MAC_HI_ADDR;
	ARP_MAC_LO_REG_04 = MAC_LO_ADDR;

   /********************  MAC Table **********************/	
    
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_0_HI_REG, MAC_0_HI);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_0_LO_REG, MAC_0_LO);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_1_HI_REG, MAC_1_HI);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_1_LO_REG, MAC_1_LO);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_2_HI_REG, MAC_2_HI);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_2_LO_REG, MAC_2_LO);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_3_HI_REG, MAC_3_HI);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_MAC_3_LO_REG, MAC_3_LO);
	
	
   /********************  DST_IP Table **********************/	
     
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_ENTRY_IP_REG, IP_REG_00);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_WR_ADDR_REG, WR_ADDR_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_ENTRY_IP_REG, IP_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_WR_ADDR_REG, WR_ADDR_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_ENTRY_IP_REG, IP_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_WR_ADDR_REG, WR_ADDR_REG_03);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_ENTRY_IP_REG, IP_REG_03);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_DST_IP_FILTER_TABLE_WR_ADDR_REG, WR_ADDR_REG_04);
	
	/********************  ARP Table **********************/	
	   
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_NEXT_HOP_IP_REG, ARP_NEXT_HOP_IP_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_HI_REG, ARP_MAC_HI_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_LO_REG, ARP_MAC_LO_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_WR_ADDR_REG, ARP_WR_ADDR_REG_01);

	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_NEXT_HOP_IP_REG, ARP_NEXT_HOP_IP_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_HI_REG, ARP_MAC_HI_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_LO_REG, ARP_MAC_LO_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_WR_ADDR_REG, ARP_WR_ADDR_REG_02);
	
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_NEXT_HOP_IP_REG, ARP_NEXT_HOP_IP_REG_03);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_HI_REG, ARP_MAC_HI_REG_03);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_LO_REG, ARP_MAC_LO_REG_03);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_WR_ADDR_REG, ARP_WR_ADDR_REG_03);
	
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_NEXT_HOP_IP_REG, ARP_NEXT_HOP_IP_REG_04);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_HI_REG, ARP_MAC_HI_REG_04);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_ENTRY_MAC_LO_REG, ARP_MAC_LO_REG_04);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ARP_TABLE_WR_ADDR_REG, ARP_WR_ADDR_REG_04);
	
	/********************  LPM Table **********************/	
	
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_IP_REG, LPM_IP_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_MASK_REG, MASK_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_NEXT_HOP_IP_REG, LPM_NEXT_HOP_IP_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_OUTPUT_PORT_REG, LPM_OUTPUT_PORT_REG_01);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_WR_ADDR_REG, LPM_WR_ADDR_REG_01);
	Sleep(1000); // Add a small delay between writing multiple LPM values for router table.  
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_IP_REG, LPM_IP_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_MASK_REG, MASK_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_NEXT_HOP_IP_REG, LPM_NEXT_HOP_IP_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_ENTRY_OUTPUT_PORT_REG, LPM_OUTPUT_PORT_REG_02);
	OnRCSlaveWrite(hDev, 0, ROUTER_OP_LUT_ROUTE_TABLE_WR_ADDR_REG, LPM_WR_ADDR_REG_02);	
	
	printf("Router Table Configuration ends \n");
}
